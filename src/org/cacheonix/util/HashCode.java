/*
 * Cacheonix systems licenses this file to You under the LGPL 2.1
 * (the "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *      http://www.cacheonix.org/products/cacheonix/license-lgpl-2.1.htm
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.cacheonix.util;

import java.io.Serializable;

import org.cacheonix.impl.util.hashcode.HashCodeCalculator;
import org.cacheonix.impl.util.hashcode.HashCodeCalculatorFactory;
import org.cacheonix.impl.util.hashcode.HashCodeCalculatorType;
import org.cacheonix.impl.util.logging.Logger;

/**
 * A utility class for generating better hash codes for cache keys.
 * <p/>
 * It is recommended that you use this class for generating hash codes for your keys. The <code>hashCode()</code> method
 * generated by an IDE most likely does not provide hash code distribution and collision rate that is adequate for
 * distributed caching and data grid environments.
 * <p/>
 * While this class can be used both for generating hash codes both for immutable and mutable keys, we strongly
 * recommend making your cache keys immutable to avoid unpredictable behavior.
 * <p/>
 * <p/>
 * <h2>Example:</h2>
 * <p/>
 * <pre>
 *   public final class ProductKey implements Serializable {
 *   <b>private final HashCode hashCode = new HashCode(HashCodeType.NORMAL);</b>
 *   private final int id;
 *   private final String name;
 *   public ProductKey(final int id, final String name) {
 *      this.id = id;
 *      this.name = name;
 *      <b>this.hashCode.add(id);</b>
 *      <b>this.hashCode.add(name);</b>
 *   }
 *   public int getID() {
 *      return id;
 *   }
 *   public String getName() {
 *      return name;
 *   }
 *   public int hashCode() {
 *      <b>return hashCode.getValue();</b>
 *   }
 *   public boolean equals(final Object o) {
 *      if (this == o) return true;
 *      if (o == null || getClass() != o.getClass()) return false;
 *      final ProductKey that = (ProductKey)o;
 *      if (id != that.id) return false;
 *      if (!name.equals(that.name)) return false;
 *      return true;
 *   }
 * }
 * </pre>
 *
 * @author <a href="mailto:simeshev@cacheonix.org">Slava Imeshev</a>
 * @noinspection NumericCastThatLosesPrecision
 * @since Apr 13, 2008 3:05:53 PM
 */
public final class HashCode implements Serializable {

   /**
    * This field should be changed whenever the internal structure of the class changes.
    */
   private static final long serialVersionUID = 0L;

   /**
    * Logger.
    *
    * @noinspection UNUSED_SYMBOL, UnusedDeclaration
    */
   private static final Logger LOG = Logger.getLogger(HashCode.class); // NOPMD

   /**
    * Hash code calculator.
    */
   private final HashCodeCalculator hashCodeCalculator;

   /**
    * True if locked.
    */
   private boolean locked = false;


   /**
    * Constructs HashCode.
    *
    * @param type of the HashCode. <code>HashCodeType.NORMAL</code> is fast and provides relatively even distribution of
    *             hash codes. <code>HashCodeType.STRONG</code> provides much better distribution of hash codes, but it
    *             is noticeably more time consuming. Use <code>HashCodeType.STRONG</code> if
    *             <code>HashCodeType.NORMAL</code> is not adequate.
    * @see HashCodeType
    */
   public HashCode(final HashCodeType type) {

      if (type.equals(HashCodeType.NORMAL)) {
         hashCodeCalculator = HashCodeCalculatorFactory.createCalculator(HashCodeCalculatorType.FNV1A32);
      } else if (type.equals(HashCodeType.STRONG)) {
         hashCodeCalculator = HashCodeCalculatorFactory.createCalculator(HashCodeCalculatorType.MD5);
      } else {
         throw new IllegalArgumentException("Unknown hash code type: " + type);
      }
   }


   /**
    * Adds a byte field of a cache key to this hash code.
    *
    * @param field a byte field to add.
    * @throws HashCodeLockedException if this hash code is locked for changes.
    * @see #lock()
    */
   public void add(final byte field) {

      verifyNotLocked();
      hashCodeCalculator.add(field);
   }


   /**
    * Adds an integer field of a cache key to this hash code.
    *
    * @param field an integer field to add.
    * @throws HashCodeLockedException if this hash code is locked for changes.
    * @see #lock()
    */
   public void add(final int field) {

      verifyNotLocked();
      hashCodeCalculator.add((byte) field);
      hashCodeCalculator.add((byte) (field >>> 8));
      hashCodeCalculator.add((byte) (field >>> 16));
      hashCodeCalculator.add((byte) (field >>> 24));
   }


   /**
    * Adds a long field of a cache key to this hash code.
    *
    * @param field a long field to add.
    * @throws HashCodeLockedException if this hash code is locked for changes.
    * @see #lock()
    */
   public void add(final long field) {

      verifyNotLocked();
      add((int) field);
      add((int) (field >>> 32));
   }


   /**
    * Adds a short field of a cache key to this hash code.
    *
    * @param field a short field to add.
    * @throws HashCodeLockedException if this hash code is locked for changes.
    * @see #lock()
    */
   public void add(final short field) {

      verifyNotLocked();
      add((byte) field);
      add((byte) (field >>> 8));
   }


   /**
    * Adds a String field of a cache key to this hash code.
    *
    * @param field a String field to add.
    * @throws HashCodeLockedException if this hash code is locked for changes.
    * @see #lock()
    */
   public void add(final String field) {

      verifyNotLocked();
      final int length = field.length();
      for (int i = 0; i < length; i++) {
         add((byte) field.charAt(i));
      }
   }


   /**
    * Locks this hash code for further changes. If the hash code is locked, a call to any of the <code>add()</code>
    * methods will throw an HashCodeLockedException.
    */
   private void lock() {

      this.locked = true;
   }


   /**
    * Adds a boolean field of a cache key to this hash code.
    *
    * @param field a boolean field to add.
    */
   public void add(final boolean field) {

      add((byte) (field ? 1 : 0));
   }


   /**
    * Adds an Object field of a cache key to this hash code.
    *
    * @param field an Object field to add.
    */
   public void add(final Object field) {

      if (field instanceof String) {
         add((String) field);
      } else {
         add(field.hashCode());
      }
   }


   /**
    * Returns calculated hash code. After this method is called first time, the hash code is locked for changes. A
    * locked hash code will throw an HashCodeLockedException if any of the <code>add()</code> methods is called.
    *
    * @return calculated hash code.
    */
   public int getValue() {

      lock();
      return hashCodeCalculator.calculate();
   }


   /**
    * Returns a hash code value for the object. This method returns the same value as {@link #getValue()}.
    *
    * @noinspection MethodNamesDifferingOnlyByCase
    */
   public int hashCode() {

      return getValue();
   }


   /**
    * Indicates whether some other object is "equal to" this one.
    */
   public boolean equals(final Object obj) {

      return obj instanceof HashCode && this.hashCode() == obj.hashCode();
   }


   private void verifyNotLocked() {

      if (locked) {
         throw new HashCodeLockedException("Cannot add a field because this hash code has been locked for changes.");
      }
   }


   public String toString() {

      return "HashCode{" +
              "value=" + hashCodeCalculator.calculate() +
              ", locked=" + locked +
              '}';
   }
}
